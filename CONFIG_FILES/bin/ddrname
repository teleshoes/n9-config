#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(sleep);

my $scoreDir = "$ENV{HOME}/Desktop/DCIM/xddr";
$scoreDir = "/home/user/pixmirror/xddr" if not -d $scoreDir;

my $EXIFTOOL_EXEC = "exiftool";
my $PIX_EXEC = "pix";

my $gnuplotDefaultPngSize = "1920,1080";

#songs with mtimes within 5m, and at least 30s between, are the same course
my $minStageGapSeconds = 30;
my $maxStageGapSeconds = 5 * 60;

my @DEFAULT_BUCKET_FIELDS = qw(song game difficulty machine);
my $bucketFieldDesc = join "-", map {"<" . uc($_) . ">"} @DEFAULT_BUCKET_FIELDS;

my $defaultNotes = {
  'extra' => 1,
  'highscore' => 0,
  'nobar' => 0,
  '3rd' => 0,
};
my $defaultNotesFormat = join ",", grep {$$defaultNotes{$_}} keys %$defaultNotes;

my @okFilters = qw(
  --song --hard --nothard
  --singles --doubles --nonstop --nonstopdoubles
  --sn2 --2013 --a
  --score --minscore --maxscore --monotonic --increasing --records
  --date --mindate
  --maxdate
  --recent --sixmos --sixmonths --6mos
  --bar --nobar --diffbar --samebar
);
my $argOptFiltersRegex = join "|", qw(
  --song --score --minscore --maxscore --mindate --date --maxdate
);

my @okFormatOptDates = qw(--showscores --reverse --short);
my $okFormatOptDatesRegex = join "|", @okFormatOptDates;
my $argOptFormatOptDatesRegex = join "|", qw();

my @okFormatOptCourses = qw(--minlen);
my $okFormatOptCoursesRegex = join "|", @okFormatOptCourses;
my $argOptFormatOptCoursesRegex = join "|", qw(--minlen);

my @okFormatOptSongs = qw(--notes --abbrev);
my $okFormatOptSongsRegex = join "|", @okFormatOptSongs;
my $argOptFormatOptSongsRegex = join "|", qw(--notes);

my @okPlotOptions = qw(--file --size --smooth);
my $okPlotOptionsRegex = join "|", @okPlotOptions;
my $argOptPlotOptionsRegex = join "|", qw( --file --size );

my @songArr = (
  ['arrabbiata'               => 'arbta' => 'hard' => 'expert'],
  ['am3pchaos'                => 'am3pc' => 'hard' => 'challenge'],
  ['b4uvoltage'               => 'b4uvs' => 'hard' => 'challenge'],
  ['bag'                      => 'bagRe' => 'hard' => 'expert'],
  ['chaos'                    => 'chaos' => 'hard' => 'expert'],
  ['fascinationeternallove'   => 'fascE' => 'hard' => 'expert'],
  ['healingdvision'           => 'hgDvn' => 'hard' => 'expert'],
  ['legendofmax'              => 'legmx' => 'hard' => 'expert'],
  ['max300'                   => 'mx300' => 'hard' => 'expert'],
  ['max300smmm'               => 'm3smm' => 'hard' => 'challenge'],
  ['max300xspecial'           => 'm3xsp' => 'hard' => 'challenge'],
  ['maxxunlimited'            => 'maxxU' => 'hard' => 'expert'],
  ['paranoiarespect'          => 'prRsp' => 'hard' => 'expert'],
  ['paranoiasurvivor270'      => 'prSur' => 'hard' => 'expert'],
  ['paranoiasurvivormax290'   => 'prSrM' => 'hard' => 'expert'],
  ['trim'                     => 'trimK' => 'hard' => 'expert'],
  ['tripmachinephoenix'       => 'trpMP' => 'hard' => 'challenge'],
  ['xepher'                   => 'xephe' => 'hard' => 'challenge'],

  ['321stars'                 => '321st' => 'other' => 'expert'],
  ['aadjamuro'                => 'aaDJA' => 'other' => 'expert'],
  ['am3p303bassmix'           => 'am3pB' => 'other' => 'challenge'],
  ['arenaissance'             => 'aRena' => 'other' => 'challenge'],
  ['astupidbarber'            => 'stBrb' => 'other' => 'expert'],
  ['b4u'                      => 'b4uNa' => 'other' => 'expert'],
  ['belovin'                  => 'beLov' => 'other' => 'expert'],
  ['blindjustice'             => 'blnJs' => 'other' => 'expert'],
  ['breakdown'                => 'brkDn' => 'other' => 'expert'],
  ['canbereal'                => 'canBR' => 'other' => 'expert'],
  ['candystar'                => 'canSt' => 'other' => 'expert'],
  ['colors'                   => 'color' => 'other' => 'challenge'],
  ['comeclean'                => 'cmCln' => 'other' => 'expert'],
  ['deadend'                  => 'dedEn' => 'other' => 'expert'],
  ['destinylovers'            => 'dstnL' => 'other' => 'expert'],
  ['dive'                     => 'diveB' => 'other' => 'expert'],
  ['doll'                     => 'dollT' => 'other' => 'challenge'],
  ['dragonblade'              => 'drgnB' => 'other' => 'expert'],
  ['dropout'                  => 'drpOt' => 'other' => 'expert'],
  ['dynamiterave'             => 'dyRav' => 'other' => 'expert'],
  ['dynamiteraveairspecial'   => 'dyRvA' => 'other' => 'challenge'],
  ['exoticethnic'             => 'exEth' => 'other' => 'expert'],
  ['flowers'                  => 'flwrs' => 'other' => 'expert'],
  ['flow'                     => 'flwJa' => 'other' => 'expert'],
  ['freedom'                  => 'fredm' => 'other' => 'expert'],
  ['groove2001'               => 'grv21' => 'other' => 'expert'],
  ['healingvision'            => 'hgVsn' => 'other' => 'expert'],
  ['healingvisionangelic'     => 'hgVnA' => 'other' => 'expert'],
  ['himawari'                 => 'himaw' => 'other' => 'expert'],
  ['holdonme'                 => 'hldOM' => 'other' => 'expert'],
  ['holic'                    => 'holic' => 'other' => 'expert'],
  ['huntingforyou'            => 'hnt4U' => 'other' => 'expert'],
  ['hypereurobeat'            => 'hyEur' => 'other' => 'expert'],
  ['insertion'                => 'insrt' => 'other' => 'expert'],
  ['jamandmarmalade'          => 'jmMar' => 'other' => 'expert'],
  ['janejana'                 => 'jneJn' => 'other' => 'expert'],
  ['jerkitout'                => 'jrkIO' => 'other' => 'expert'],
  ['loveisorange'             => 'lvOrn' => 'other' => 'expert'],
  ['magicdoor'                => 'mgcDr' => 'other' => 'expert'],
  ['marswar3'                 => 'mrsWr' => 'other' => 'expert'],
  ['matsurijapan'             => 'matsu' => 'other' => 'expert'],
  ['maximizer'                => 'mxmzr' => 'other' => 'expert'],
  ['mexicanfolksong'          => 'mexFS' => 'other' => 'expert'],
  ['midnightspecial'          => 'midNS' => 'other' => 'expert'],
  ['mugen'                    => 'mugen' => 'other' => 'expert'],
  ['mysummerlove'             => 'mySLv' => 'other' => 'expert'],
  ['no13'                     => 'no13T' => 'other' => 'expert'],
  ['orioneuro'                => 'ornEu' => 'other' => 'expert'],
  ['orioncivilization'        => 'ornCi' => 'other' => 'expert'],
  ['paranoia'                 => 'paran' => 'other' => 'expert'],
  ['paranoiaeternalstm200'    => 'prEte' => 'other' => 'expert'],
  ['paranoiaevolution200'     => 'prEvo' => 'other' => 'expert'],
  ['paranoiamaxdirtymix190'   => 'prDrt' => 'other' => 'expert'],
  ['peace'                    => 'peace' => 'other' => 'expert'],
  ['pinkrose'                 => 'pnkRs' => 'other' => 'expert'],
  ['pluto'                    => 'pluto' => 'other' => 'expert'],
  ['putyourfaithinme'         => 'PYFIM' => 'other' => 'expert'],
  ['rainbowflyer'             => 'rbFly' => 'other' => 'expert'],
  ['rainbowrainbow'           => 'rnbow' => 'other' => 'expert'],
  ['raspberryheart'           => 'rspHr' => 'other' => 'expert'],
  ['rememberyou'              => 'remYo' => 'other' => 'expert'],
  ['sakura'                   => 'sakra' => 'other' => 'expert'],
  ['sanamollete'              => 'sanaM' => 'other' => 'expert'],
  ['seduction'                => 'sdctn' => 'other' => 'expert'],
  ['senoritavirtual'          => 'senVi' => 'other' => 'expert'],
  ['stealth'                  => 'stlth' => 'other' => 'expert'],
  ['sunkissdrop'              => 'snkDr' => 'other' => 'expert'],
  ['sunrise'                  => 'sunri' => 'other' => 'expert'],
  ['sweetsweetmagic'          => 'swtMa' => 'other' => 'expert'],
  ['tripmachine'              => 'trpMa' => 'other' => 'expert'],
  ['tripmachinesurvivor'      => 'trpMS' => 'other' => 'expert'],
  ['tsugaru'                  => 'tsuga' => 'other' => 'expert'],
  ['tsugaruapplemix'          => 'tsuAM' => 'other' => 'challenge'],
  ['trust'                    => 'trust' => 'other' => 'expert'],
  ['try2luvyou'               => 'try2L' => 'other' => 'expert'],
  ['twomonthsoff'             => 'twoMO' => 'other' => 'expert'],
  ['vforextreme'              => 'v4Ext' => 'other' => 'challenge'],
  ['whynot'                   => 'whyNt' => 'other' => 'expert'],

  ['bemanispirits'            => 'nonBS' => 'other' => 'difficult'],
  ['classic'                  => 'nonCL' => 'other' => 'difficult'],
  ['skipmaster'               => 'nonSM' => 'other' => 'difficult'],
  ['terra'                    => 'nonTR' => 'other' => 'difficult'],
);

my %songAbbrevs = map { $$_[0] => $$_[1] } @songArr;
my %defaultDifficulty = map { $$_[0] => $$_[3] } @songArr;

my @hardSongs = map { $$_[0] } grep { $$_[2] eq 'hard' } @songArr;
my $okHardSongs = join '|', @hardSongs;

my @otherSongs = map { $$_[0] } grep { $$_[2] eq 'other' } @songArr;
my $okOtherSongs = join '|', @otherSongs;

my @songArgs = sort {$a cmp $b} (@hardSongs, @otherSongs);
my $okSongArgs = join '|', @songArgs;

my @gameArgs = qw(singles doubles nonstop nonstopdoubles);
my $singlesGameArg = "singles";
my $okGameArgs = join '|', @gameArgs;

my %gameAbbrevs = (
  singles => 'SGL',
  doubles => 'DBL',
  nonstop => 'NON',
  nonstopdoubles => 'NDB',
);

my @difficultyArgs = qw(beginner basic difficult expert challenge);
my $okDifficultyArgs = join '|', @difficultyArgs;

my %difficultyAbbrevs = (
  beginner => 'beg',
  basic => 'bas',
  difficult => 'dif',
  expert => 'exp',
  challenge => 'cha',
);

my @machineArgs = qw(sn2 2013 a);
my $defaultMachineArg = "sn2";
my $okMachineArgs = join '|', @machineArgs;

my @stageArgs = qw(1st 2nd 3rd 4extra 4nonstop);
my $okStageArgs = join '|', @stageArgs;

my @barArgs = qw(bar nobar);
my $okBarArgs = join '|', @barArgs;

my @extraArgs = qw(fc pfc);
my $okExtraArgs = join '|', @extraArgs;

my $usage = "Usage:
  $0 --fehterm
    -open a terminal using term and get its window id with xwininfo
    -open feh with --info set to type in the newly opened terminal with xdotool

  $0 --orientation [FILTER FILTER ..]
    for each song file, print \"<orientation> <filename>\",
      where orientation is one of \"landscape\", \"portrait\", or \"unknown\"
    uses \"$EXIFTOOL_EXEC\", falling back on \"$PIX_EXEC\"

  $0 --datestats [FORMAT_OPT_DATES FORMAT_OPT_DATES ..] [FILTER FILTER ..]
    format stats for each date

    FORMAT_OPT_DATES
      --showscores
        show all scores, one per line, instead of just a count
      --reverse
        print newest dates first, instead of oldest dates first
      --short
        dont show individual songs at all

    FILTER
      see --print FILTER

  $0 --coursestats [FORMAT_OPT_COURSES FORMAT_OPT_COURSES ..] [FILTER FILTER ..]
    show songs that appear to be part of the same course, played back-to-back
    songs must be of increasing stage number,
      and have mtimes at most 5min between successive stages.
      (stages can be missing; an extra 5min is allowed for any gaps)
    e.g.:
      A 1st 12:00
      B 2nd 12:03
      C 3rd 12:07
      D 1st 12:11
      E 3rd 12:17
      F 1st 12:38
      G 2nd 12:46
      H 3rd 12:47
      => [A-B-C], [D-E], [F], [G-H]
         A and B and C are a normal stage, less than 5 between each
         C and D are not sequential stages
         D and E are within 5min+5min, with gap for missing 2nd
         F and G are NOT within 5min
         G and G are within 5min
         F and H are within 5min+5min, but 2nd is not missing

    FORMAT_OPT_COURSES
      --minlen LENGTH
        show only courses where at least LENGTH scores are recorded
        default is: 2
        LENGTH=3
          show only courses with 3 or more songs recorded (after filtering)
        LENGTH=2 {default}
          show only courses with 2 or more songs recorded (after filtering)
        LENGTH=1 or LENGTH=0
          show all courses,, even if only one score recorded (after filtering)

    FILTER
      see --print FILTER

  $0 --print [FORMAT_OPT_SONGS FORMAT_OPT_SONGS ..] [FILTER FILTER ..]
    parse filenames of score pictures in $scoreDir
      and print the result

    each successive FILTER can only remove scores
    specifying the same FILTER twice is legal, but useless
    some FILTERs override others as indicated, so specifying both is useless

    FORMAT_OPT_SONGS
      --notes NOTES_CSV
        comma-separated list of notes to add.
        default is '$defaultNotesFormat'.
        use empty string for none

        extra
          add EXTRA if EXTRA is set for the song
        highscore
          add 'SCORE SONG' if SCORE is the highest in the bucket
        nobar
          add 'nobar' if SONG is a HARD_SONG and BAR is 'nobar'
        3rd
          add '3rd' if SONG is a HARD_SONG and STAGE is '3rd'
      --abbrev
        shorten bucket names by using song abbreviations

    FILTER: SONG
      --song REGEX
        include only scores where the whole SONG string matches REGEX
        {overrides --hard and --nothard}
      --hard
        include only scores where SONG is a HARD_SONG
        {overrides --nothard and --song}
      --nothard
        include only scores where SONG is not a HARD_SONG
        {overrides --song and --hard}

    FILTER: GAME
      --singles
        include only scores where GAME is singles OR not defined
        {overrides --doubles and --nonstop and --nonstopdoubles}
      --doubles
        include only scores where GAME is doubles
        {overrides --singles and --nonstop and --nonstopdoubles}
      --nonstop
        include only scores where GAME is nonstop
        {overrides --singles and --doubles and --nonstopdoubles}
      --nonstopdoubles
        include only scores where GAME is nonstopdoubles
        {overrides --singles and --nonstop and --doubles}

    FILTER: MACHINE
      --sn2
        include only scores where MACHINE is sn2
      --2013
        include only scores where MACHINE is 2013
      --a
        include only scores where MACHINE is a

    FILTER: SCORE
      --score N, --minscore N
        include only scores where SCORE >= N
      --maxscore N
        include only scores where SCORE <= N
      --monotonic, --increasing, --records
        disclude any score that is lower than any score from a previous date,
        with the same $bucketFieldDesc

    FILTER: DATE
      --date YYYYMMDD, --mindate YYYYMMDD
        include only scores where DATE >= YYYYMMDD
        {overrides --recent}
      --maxdate YYYYMMDD
        include only scores where DATE <= YYYYMMDD
      --recent, --sixmos, --sixmonths, --6mos
        same as '--mindate N', where N is the date 180 days ago
        {overrides --date}

    FILTER: BAR
      --bar
        include only scores where BAR=bar
      --nobar
        include only scores where BAR=nobar
      --diffbar
        include only scores where BAR is different than at least half of all
          scores with the same \"$bucketFieldDesc\"
          (counted against all scores, before any filtering)
      --samebar
        include only scores where BAR is the same as at least half of all
          scores with the same \"$bucketFieldDesc\"
          (counted against all scores, before any filtering)

      e.g.:
        TOTAL|BAR=bar|BAR=nobar|--bar |--nobar |--diffbar|--samebar
        =====|=======|=========|======|========|=========|===========
        2    |1      |1        |B1 N0 |B0 N1   |B1 N1    |B1 N1
        2    |2      |0        |B2 N0 |B0 N0   |B0 N0    |B2 N0
        3    |1      |2        |B1 N0 |B0 N2   |B1 N0    |B0 N2
        4    |2      |2        |B2 N0 |B0 N2   |B2 N2    |B2 N2

        the 3rd row, in english, says if there are 3 songs recorded
          for the given $bucketFieldDesc,
          and 1 has BAR=bar, and 2 have BAR=nobar, then:
            --bar will show the one with BAR=bar
            --nobar will show the two with BAR=nobar
            --diffbar will show the one with BAR=bar
            --samebar will show the two with BAR=nobar


    scores are grouped into sections by \"$bucketFieldDesc\"
      '<GAME>-' is omitted if GAME is '$singlesGameArg' (or missing)
      '<MACHINE>-' is omitted if MACHINE is '$defaultMachineArg'
    each section starts with the name, and then contains the scores,
      one per line, formatted '<date>,<score>,<notes>'
    sections are separated by two newlines
    <notes> are space-separated list of:
      EXTRA   if one of [$okExtraArgs] is present in the filename
      nobar   if SONG is a HARD_SONG
      3rd     if SONG is a HARD_SONG

      e.g.: \"max300-doubles-expert\"
            20140331,723150,
            20140401,990000,pfc nobar
            20140402,684120,nobar
            20140403,784120,fc


            \"paranoiarespect-expert\"
            20140331,723150,

  $0 --gnuplot [PLOT_OPTION PLOT_OPTION ..] [FORMAT_OPT_SONGS FORMAT_OPT_SONGS ..] [FILTER FILTER ..]
    format songs as above and write to a tmp file
    write a gnuplot script and run it in gnuplot
      all PLOT_OPTIONs must precede all FILTERs

    PLOT_OPTION
      --file PNG_FILE_PATH
        output PNG file to indicated path

      --size PNG_SIZE
        output PNG pixelsize, WIDTHxHEIGHT
        'x' can be any combination of spaces, commas, and 'x's
        default is: $gnuplotDefaultPngSize

      --smooth
        use 'smooth bezier' instead of 'with linespoints'
        also turns off all notes unless --notes is given

    FORMAT_OPT_SONGS
      see --print FORMAT_OPT_SONGS

    FILTER
      see --print FILTER

  $0 --files [FILTER FILTER ..]
    print the filenames, one per line without directories, of matching songs

    FILTER
      see --print FILTER

  $0 --bestfiles [FILTER FILTER ..]
    print the filename of the highest score for each set of scores with the same:
      $bucketFieldDesc

    FILTER
      see --print FILTER

  $0 JPG_FILE REMINDER

    rename a jpeg file, adding '_<REMINDER>' before .jpg

     JPG_FILE
       jpeg file to rename
       must start with '########_###' and end with '.jpg'

     REMINDER
       text to append
       can optionally start with the same prefix as JPG_FILE ('########_###')
         and/or end in '.jpg', in which case the prefix or suffix are removed
       must start with 'reminder_' or 'closeup_',
         contain only letters, numbers, and underscores,
         and end with a letter or number

  $0 JPG_FILE [ARG ARG ..]

    rename a jpeg file using a consistent format
    \"########_###_SONG_GAME_DIFFICULTY_MACHINE_SCORE_EXTRA_BAR_STAGE.jpg\"
    ######## is presumably a date in YYYYMMDD and ### is the camera pic index

     JPG_FILE
       jpeg file to rename
       must start with '########_###' and end with '.jpg'

     ARG
       one of [SONG|GAME|DIFFICULTY|MACHINE|SCORE|STAGE|BAR|EXTRA]
       exactly one SONG, DIFFICULTY, SCORE, STAGE, and BAR must be given
       exactly zero or one GAME args can be given  {missing means 'singles'}
       exactly zero or one MACHINE args can be given  {defaults to '$defaultMachineArg'}
       exactly zero or one EXTRA args can be given  {optional}

     SONG
       one of <HARD_SONG> or <OTHER_SONG>
     HARD_SONG
       one of [$okHardSongs]
     OTHER_SONG
       one of [$okOtherSongs]

     GAME
       one of [$okGameArgs]  {missing means 'singles'}

     DIFFICULTY
       one of [$okDifficultyArgs]

     MACHINE
       one of [$okMachineArgs]  {defaults to '$defaultMachineArg'}

     SCORE
       an integer between 100,000 and 1,000,000
       must be a multiple of 10
       commas, if present, are stripped out

     EXTRA
       one of [$okExtraArgs]  {optional}

     BAR
       one of [$okBarArgs]

     STAGE
       one of [$okStageArgs]

  $0 --bash-complete COMP_LINE COMP_POINT
     print a list of words for bash completion, one per line
     COMP_LINE  - the full cmdline as a string
     COMP_POINT - the cursor position in the cmdline
";

sub fehterm($@);
sub orientation($@);
sub dateStats($@);
sub courseStats($@);
sub scoreStats($@);
sub parsePlotOptions($);
sub parseFilterOptions($);
sub name(@);
sub nameReminder($$);
sub parseArgs(@);
sub getScoresByFile();
sub listScoreFiles();
sub parseScoreFile($);
sub sortScores($);
sub getBucketName($$@);
sub getScoreBuckets($$@);
sub formatBucketCsv($$$);
sub getBucketBarCounts($);
sub filterScores($$);
sub formatScores($$$);
sub getBestScores($);
sub gnuplot($$);
sub combine(@);
sub mtime($);
sub getImageOrientation($);
sub bashComplete($$);
sub warnMsg($);
sub run(@);

sub main(@){
  if(@_ == 3 and $_[0] =~ /^--bash-complete$/ and $_[2] =~ /^\d+$/){
    print map {"$_\n"} bashComplete($_[1], $_[2]);
    exit 0;
  }

  if(@_ == 1 and $_[0] =~ /^(--fehterm)$/){
    my $cmd = shift;
    fehterm($cmd, @_);
  }elsif(@_ >= 1 and $_[0] =~ /^(--orientation)$/){
    my $cmd = shift;
    orientation($cmd, @_);
  }elsif(@_ >= 1 and $_[0] =~ /^(--datestats)$/){
    my $cmd = shift;
    dateStats($cmd, @_);
  }elsif(@_ >= 1 and $_[0] =~ /^(--coursestats)$/){
    my $cmd = shift;
    courseStats($cmd, @_);
  }elsif(@_ >= 1 and $_[0] =~ /^(--print|--gnuplot|--files|--bestfiles)$/){
    my $cmd = shift;
    scoreStats($cmd, @_);
  }elsif(@_ == 2 and $_[0] =~ /\.jpg$/){
    nameReminder($_[0], $_[1]);
  }elsif(@_ > 1 and $_[0] =~ /\.jpg$/){
    name(@_);
  }else{
    die $usage;
  }
}

sub fehterm($@){
  my $cmd = shift;
  die $usage if @_ != 0;

  my $windowTitle = "ddrname-fehterm";
  run ("term",
    "-t", $windowTitle,
    "export WINDOW_TITLE=$windowTitle; bash",
  );
  sleep 0.5;

  my $xwininfo = `xwininfo -name '$windowTitle'`;
  if($xwininfo !~ /Window id: (0x[0-9a-f]+) "$windowTitle"/){
    die "Could not find window id for name=$windowTitle\n";
  }
  my $windowId = $1;

  my $infoCmd = ""
    . "xdotool key --delay 1 --window $windowId" . (" BackSpace" x 50) . "; "
    . "xdotool type --window $windowId 'ddrname \%f '; "
    . "echo %f; "
    ;

  run "/usr/bin/feh", "-g", "800x800+50+50", "--info", $infoCmd;
}

sub orientation($@){
  my $cmd = shift;
  my $opts = [@_];

  my $filters = parseFilterOptions $opts;
  my $scoresByFile = getScoresByFile();
  $scoresByFile = filterScores $scoresByFile, $filters;

  for my $file(sort keys %$scoresByFile){
    my $orientation = getImageOrientation "$scoreDir/$file";
    $orientation = "unknown" if not defined $orientation;
    print "$orientation $file\n";
  }
}

sub dateStats($@){
  my $cmd = shift;
  my $opts = [@_];

  my $showScores = 0;
  my $reverse = 0;
  my $short = 0;
  while(@$opts > 0 and $$opts[0] =~ /^($okFormatOptDatesRegex)$/){
    my $opt = shift @$opts;
    my $arg;
    if($opt =~ /^($argOptFormatOptDatesRegex)$/){
      die "malformed or missing argument to $opt\n" if @$opts == 0;
      $arg = shift @$opts;
    }

    if($opt =~ /^(--showscores)$/){
      $showScores = 1;
    }elsif($opt =~ /^(--reverse)$/){
      $reverse = 1;
    }elsif($opt =~ /^(--short)$/){
      $short = 1;
    }
  }

  my $filters = parseFilterOptions $opts;

  die $usage if @$opts != 0;

  my $scoresByFile = getScoresByFile();
  $scoresByFile = filterScores $scoresByFile, $filters;

  my %mtimes;

  for my $file(keys %$scoresByFile){
    my $mtime = mtime "$scoreDir/$file";
    $mtimes{$file} = $mtime;
  }

  my $dateBuckets = {};
  for my $file(sort keys %$scoresByFile){
    my $score = $$scoresByFile{$file};
    my $mtime = $mtimes{$file};
    my $date = `date --date \@$mtime +%Y%m%d`;
    chomp $date;
    $$dateBuckets{$date} = [] if not defined $$dateBuckets{$date};
    push @{$$dateBuckets{$date}}, $score;
  }

  my %isHardSong = map {$_ => 1} @hardSongs;

  my @dates = sort keys %$dateBuckets;
  @dates = reverse @dates if $reverse;

  for my $date(@dates){
    my @dateScores = @{$$dateBuckets{$date}};
    my $totalCount = 0;
    my $hardSinglesCount = 0;
    my $doublesCount = 0;
    my $total = @dateScores;
    for my $score(@dateScores){
      if($$score{game} eq "doubles"){
        $doublesCount++;
      }elsif($isHardSong{$$score{song}}){
        $hardSinglesCount++;
      }
      $totalCount++;
    }

    my $dateEpoch = `date +%s --date=$date`;
    chomp $dateEpoch;

    my $minMtime = undef;
    my $maxMtime = undef;

    my $buckets = getScoreBuckets \@dateScores, 1, @DEFAULT_BUCKET_FIELDS;
    my @bucketSummary;
    for my $bucketName(sort keys %$buckets){
      my @scores = @{$$buckets{$bucketName}};
      my $first = $scores[0];

      my $isDoubles = $$first{game} eq "doubles" ? 1 : 0;
      my $hardSong = $isHardSong{$$first{song}} ? 1 : 0;

      for my $score(@scores){
        my $file = $$score{file};
        my $mtime = $mtimes{$file};

        my $dateDiff = $dateEpoch - $mtime;
        $dateDiff *= -1 if $dateDiff < 0;
        if($dateDiff > 1*24*60*60){
          next;
        }

        $minMtime = $mtime if not defined $minMtime or $mtime < $minMtime;
        $maxMtime = $mtime if not defined $maxMtime or $mtime > $maxMtime;
      }

      my $count = @scores;
      push @bucketSummary, {
        name=>$bucketName,
        count=>$count,
        isDoubles=>$isDoubles ? 1 : 0,
        isHardSingles=>(not $isDoubles and $hardSong) ? 1 : 0,
        scores=>[reverse sort map {$$_{score}} @scores],
      };
    }

    my $elapsedMin;
    if(defined $minMtime and defined $maxMtime){
      $elapsedMin = ($maxMtime - $minMtime) / 60;
    }else{
      $elapsedMin = 0;
    }

    my $fmt = "";
    $fmt .= sprintf "%s %2d-T %2d-H %2d-D  %3dm",
      $date, $totalCount, $hardSinglesCount, $doublesCount, $elapsedMin;

    @bucketSummary = sort {
      $$b{count} <=> $$a{count}
        or $$b{isHardSingles} <=> $$a{isHardSingles}
        or $$b{isDoubles} <=> $$a{isDoubles}
        or $b cmp $a
    } @bucketSummary;

    if(not $short){
      for my $summary(@bucketSummary){
        if($showScores){
          $fmt .= sprintf "\n  %-9s %s", $$summary{name}, "@{$$summary{scores}}";
        }else{
          $fmt .= sprintf "  %2d %s", $$summary{count}, $$summary{name};
        }
      }
      if($showScores){
        $fmt .= "\n";
      }
    }

    print "$fmt\n";
  }
}

sub courseStats($@){
  my $cmd = shift;
  my $opts = [@_];

  my $minlen = 2;
  while(@$opts > 0 and $$opts[0] =~ /^($okFormatOptCoursesRegex)$/){
    my $opt = shift @$opts;
    my $arg;
    if($opt =~ /^($argOptFormatOptCoursesRegex)$/){
      die "malformed or missing argument to $opt\n" if @$opts == 0;
      $arg = shift @$opts;
    }
    if($opt =~ /^(--minlen)$/){
      $minlen = $arg;
    }
  }

  my $filters = parseFilterOptions $opts;

  die $usage if @$opts != 0;

  my $stageNums = {
    "1st" => 1,
    "2nd" => 2,
    "3rd" => 3,
    "4extra" => 4,
    "4nonstop" => 4,
  };

  my $scoresByFile = getScoresByFile();
  $scoresByFile = filterScores $scoresByFile, $filters;

  my $mtimes = {};
  for my $file(keys %$scoresByFile){
    $$mtimes{$file} = mtime "$scoreDir/$file";
  }

  my @sortedScores = sort {
    $$mtimes{$a} <=> $$mtimes{$b}
    || $a cmp $b
  } keys %$scoresByFile;

  my @courses;
  my $curCourse = undef;
  my $lastStageNum = undef;
  my $lastMtime = undef;
  for my $file(@sortedScores){
    my $score = $$scoresByFile{$file};
    my $mtime = $$mtimes{$file};
    my $stage = $$score{stage};
    my $stageNum = $$stageNums{$stage};
    die "invalid stage '$stage'\n" if not defined $stageNum;

    my $isNewCourse = 0;
    if(defined $lastStageNum && defined $lastMtime){
      die "mtimes out of order at $file\n" if $lastMtime > $mtime;
      my $stageNumDiff = $stageNum - $lastStageNum;
      my $mtimeDiff = $mtime - $lastMtime;

      my $minMtimeDiff = $minStageGapSeconds*$stageNumDiff;
      my $maxMtimeDiff = $maxStageGapSeconds*$stageNumDiff;

      if($stageNumDiff <= 0){
        $isNewCourse = 1;
      }elsif($mtimeDiff < $minMtimeDiff or $mtimeDiff > $maxMtimeDiff){
        $isNewCourse = 1;
      }
    }

    if(not defined $curCourse or $isNewCourse){
      $curCourse = [];
      push @courses, $curCourse;
    }
    push @$curCourse, $score;

    $lastStageNum = $stageNum;
    $lastMtime = $mtime;
  }

  @courses = grep {@$_ >= $minlen} @courses;

  for my $course(@courses){
    my $first = ${$course}[0];
    my $fmt = "$$first{date}:";
    for my $score(@$course){
      $fmt .= " " . getBucketName $score, 1, @DEFAULT_BUCKET_FIELDS;
    }
    $fmt .= "\n";
    for my $score(@$course){
      my $abbrevBucketName = getBucketName $score, 1, @DEFAULT_BUCKET_FIELDS;
      $fmt .= "  $$score{stage} $$score{score} $abbrevBucketName\n";
    }
    print $fmt;
  }
}

sub scoreStats($@){
  my $cmd = shift;
  my $opts = [@_];

  my $plotOptions = parsePlotOptions $opts if $cmd =~ /^(--gnuplot)$/;

  my $okNotes = $defaultNotes;
  if($$plotOptions{smooth}){
    $okNotes = {map {$_ => 0} keys %$okNotes};
  }

  my $abbrevBucket = 0;

  if($cmd =~ /^(--print|--gnuplot)/){
    while(@$opts > 0 and $$opts[0] =~ /^($okFormatOptSongsRegex)$/){
      my $opt = shift @$opts;
      my $arg;
      if($opt =~ /^($argOptFormatOptSongsRegex)$/){
        die "malformed or missing argument to $opt\n" if @$opts == 0;
        $arg = shift @$opts;
      }
      if($opt =~ /^(--notes)$/){
        my $notesCsv = $arg;
        $$okNotes{$_} = 0 foreach keys %$okNotes;

        my @notes = split /\s*,\s*/, $notesCsv;
        for my $note(@notes){
          die "invalid $opt: $arg\n" if not defined $$okNotes{$note};
          $$okNotes{$note} = 1;
        }
      }elsif($opt =~ /^(--abbrev)$/){
        $abbrevBucket = 1;
      }
    }
  }

  my $filters = parseFilterOptions $opts;

  if($cmd =~ /^(--print)$/){
    my $fmt = formatScores($okNotes, $abbrevBucket, $filters);
    print $fmt;
  }elsif($cmd =~ /^(--gnuplot)$/){
    my $fmt = formatScores($okNotes, $abbrevBucket, $filters);
    gnuplot $plotOptions, $fmt;
  }elsif($cmd =~ /^(--files)$/){
    my $scoresByFile = getScoresByFile();
    $scoresByFile = filterScores $scoresByFile, $filters;
    print join '', map {"$_\n"} sort keys %$scoresByFile;
  }elsif($cmd =~ /^(--bestfiles)$/){
    my $bestScores = getBestScores($filters);
    for my $bucketName(sort keys %$bestScores){
      print $$bestScores{$bucketName}{file} . "\n";
    }
  }
}

sub parsePlotOptions($){
  my $opts = shift;
  my $plotOptions = {};
  while(@$opts > 0 and $$opts[0] =~ /^($okPlotOptionsRegex)$/){
    my $opt = shift @$opts;
    my $arg;
    if($opt =~ /^($argOptPlotOptionsRegex)$/){
      die "$usage\nmissing arg to $opt\n" if @$opts == 0;
      $arg = shift @$opts;
    }

    if($opt =~ /^(--file)$/){
      $$plotOptions{file} = $arg;
    }elsif($opt =~ /^(--size)$/){
      die "$usage\ninvalid $opt: $arg\n" if $arg !~ /^(\d+)[ ,x]+(\d+)$/;
      $$plotOptions{size} = "$1,$2";
    }elsif($opt =~ /^(--smooth)$/){
      $$plotOptions{smooth} = 1;
    }
  }
  return ($opts, $plotOptions);
}

sub parseFilterOptions($){
  my $opts = shift;
  my $filters = {};
  while(@$opts > 0){
    my $opt = shift @$opts;
    my $arg;
    if($opt =~ /^($argOptFiltersRegex)$/){
      die "$usage\nmissing arg to $opt\n" if @$opts == 0;
      $arg = shift @$opts;
    }

    if($opt =~ /^(--song)$/){
      die "$usage\nmissing arg to $opt\n" if not defined $arg;
      my $regex = "^$arg\$";
      $$filters{songs} = {map {$_ => $_ =~ m/$regex/ ? 1 : 0} @songArgs};
    }elsif($opt =~ /^(--hard)$/){
      my $regex = "^($okHardSongs)\$";
      $$filters{songs} = {map {$_ => $_ =~ m/$regex/ ? 1 : 0} @songArgs};
    }elsif($opt =~ /^(--nothard)$/){
      my $regex = "^($okOtherSongs)\$";
      $$filters{songs} = {map {$_ => $_ =~ m/$regex/ ? 1 : 0} @songArgs};
    }elsif($opt =~ /^(--singles)$/){
      $$filters{game} = {singles => 1, doubles => 0, nonstop => 0, nonstopdoubles => 0};
    }elsif($opt =~ /^(--doubles)$/){
      $$filters{game} = {singles => 0, doubles => 1, nonstop => 0, nonstopdoubles => 0};
    }elsif($opt =~ /^(--nonstop)$/){
      $$filters{game} = {singles => 0, doubles => 0, nonstop => 1, nonstopdoubles => 0};
    }elsif($opt =~ /^(--nonstopdoubles)$/){
      $$filters{game} = {singles => 0, doubles => 0, nonstop => 0, nonstopdoubles => 1};
    }elsif($opt =~ /^(--sn2)$/){
      $$filters{machine} = {sn2 => 1, 2013 => 0, a => 0};
    }elsif($opt =~ /^(--2013)$/){
      $$filters{machine} = {sn2 => 0, 2013 => 1, a => 0};
    }elsif($opt =~ /^(--a)$/){
      $$filters{machine} = {sn2 => 0, 2013 => 0, a => 1};
    }elsif($opt =~ /^(--score|--minscore)$/){
      die "$usage\ninvalid $opt: $arg\n" if $arg !~ /^(\d+)$/;
      $$filters{minscore} = $1;
    }elsif($opt =~ /^(--maxscore)$/){
      die "$usage\ninvalid $opt: $arg\n" if $arg !~ /^(\d+)$/;
      $$filters{maxscore} = $1;
    }elsif($opt =~ /^(--mindate|--date)$/){
      die "$usage\ninvalid $opt: $arg\n" if $arg !~ /^(\d{8})$/;
      $$filters{mindate} = $1;
    }elsif($opt =~ /^(--monotonic|--increasing|--records)$/){
      $$filters{monotonic} = 1;
    }elsif($opt =~ /^(--recent|--sixmonths|--sixmos|--6mos)$/){
      eval {
        require DateTime;
        DateTime->import();
        1;
      } or die "--recent requires missing module DateTime\n";
      my $sixmos = DateTime->now->subtract(days=>180)->strftime('%Y%m%d');
      $$filters{mindate} = $sixmos;
    }elsif($opt =~ /^(--maxdate)$/){
      die "$usage\ninvalid $opt: $arg\n" if $arg !~ /^(\d{8})$/;
      $$filters{maxdate} = $1;
    }elsif($opt =~ /^(--bar)$/){
      $$filters{bar} = "bar";
    }elsif($opt =~ /^(--nobar)$/){
      $$filters{bar} = "nobar";
    }elsif($opt =~ /^(--diffbar)$/){
      $$filters{bar} = "diff";
    }elsif($opt =~ /^(--samebar)$/){
      $$filters{bar} = "same";
    }else{
      die "$usage\nunknown filter: $opt\n";
    }
  }
  return $filters;
}

sub nameReminder($$){
  my ($file, $reminder) = @_;

  $file =~ s/^\.\///;

  if($file !~ /^(\d{8}_\d{3,}).*\.jpg$/){
    die "misnamed jpg file: $file\n";
  }
  my $prefix = $1;
  $reminder =~ s/^$prefix//;
  $reminder =~ s/\.jpg$//;

  if($reminder !~ /^(reminder|closeup)_[a-zA-Z0-9_]*[a-zA-Z0-9]$/){
    die "invalid reminder: $reminder\n";
  }

  my $newFileName = "${prefix}_${reminder}.jpg";

  my @cmd = ("mv", $file, $newFileName);
  run @cmd;
}

sub name(@){
  my $file = shift;
  my $info = parseArgs @_;
  die $usage if not defined $file or not -f $file or not defined $info;
  die "missing SONG\n" if not defined $$info{song};
  die "missing GAME\n" if not defined $$info{game};
  die "missing DIFFICULTY\n" if not defined $$info{difficulty};
  die "missing MACHINE\n" if not defined $$info{machine};
  die "missing SCORE\n" if not defined $$info{score};
  die "missing BAR\n" if not defined $$info{bar};
  die "missing STAGE\n" if not defined $$info{stage};

  my $bucketName = getBucketName $info, 0, @DEFAULT_BUCKET_FIELDS;

  my $scoresByFile = getScoresByFile();
  my $scores = [values %$scoresByFile];
  my $buckets = getScoreBuckets($scores, 0, @DEFAULT_BUCKET_FIELDS);

  my $orient = getImageOrientation $file;
  my $game = $$info{game};
  if(not defined $orient){
    warnMsg("unknown orientation");
  }elsif($orient eq "landscape" and $game =~ /^(singles|nonstop)$/){
    warnMsg("image orientation is $orient, which is unusual for game=$game");
  }elsif($orient eq "portrait" and $game =~ /^(doubles|nonstopdoubles)$/){
    warnMsg("image orientation is $orient, which is unusual for game=$game");
  }

  if(not defined $$buckets{$bucketName}){
    warnMsg("no existing scores found for $bucketName");
  }else{
    my $minScore = 0;
    my $maxScore = 0;
    for my $score(@{$$buckets{$bucketName}}){
      $minScore = $$score{score} if $$score{score} < $minScore;
      $maxScore = $$score{score} if $$score{score} > $maxScore;
    }
    if($$info{score} < $minScore){
      warnMsg("new LOW score $minScore => $$info{score}");
    }elsif($$info{score} > $maxScore){
      warnMsg("new HIGH score $maxScore => $$info{score}");
    }

    my $bucketBarCounts = getBucketBarCounts $buckets;
    my $barCount = $$bucketBarCounts{$bucketName}{bar};
    my $nobarCount = $$bucketBarCounts{$bucketName}{nobar};
    if($$info{bar} eq "bar" and $barCount < $nobarCount){
      warnMsg("$bucketName is usually 'nobar'");
    }elsif($$info{bar} eq "nobar" and $nobarCount < $barCount){
      warnMsg("$bucketName is usually 'bar'");
    }
  }

  $file =~ s/^\.\///;

  if($file !~ /^(\d{8}_\d{3,}).*\.jpg$/){
    die "misnamed jpg file: $file\n";
  }
  my $prefix = $1;

  my $newFileName = '';
  $newFileName .= "$prefix";
  $newFileName .= "_$$info{song}";
  $newFileName .= "_$$info{game}" if $$info{game} ne $singlesGameArg;
  $newFileName .= "_$$info{difficulty}";
  $newFileName .= "_$$info{machine}";
  $newFileName .= "_$$info{score}";
  $newFileName .= "_$$info{extra}" if defined $$info{extra};
  $newFileName .= "_$$info{bar}";
  $newFileName .= "_$$info{stage}";
  $newFileName .= ".jpg";

  my @cmd = ("mv", $file, $newFileName);
  run @cmd;
}

sub parseArgs(@){
  my $info = {};
  for my $arg(@_){
    if($arg =~ /^($okSongArgs)$/){
      return undef if defined $$info{song};
      $$info{song} = $arg;
    }elsif($arg =~ /^($okGameArgs)$/){
      return undef if defined $$info{game};
      $$info{game} = $arg;
    }elsif($arg =~ /^($okDifficultyArgs)$/){
      return undef if defined $$info{difficulty};
      $$info{difficulty} = $arg;
    }elsif($arg =~ /^($okMachineArgs)$/){
      return undef if defined $$info{machine};
      $$info{machine} = $arg;
    }elsif($arg =~ /^(\d,?){5,6}(\d)$/){
      warnMsg("score non-multiple-of-ten: $arg") if $2 != 0;
      my $score = $arg;
      $score =~ s/,//g;
      $score = int($score);
      return undef if defined $$info{score} or $score > 1000000;
      $$info{score} = $score;
    }elsif($arg =~ /^($okExtraArgs)$/){
      return undef if defined $$info{extra};
      $$info{extra} = $arg;
    }elsif($arg =~ /^($okBarArgs)$/){
      return undef if defined $$info{bar};
      $$info{bar} = $arg;
    }elsif($arg =~ /^($okStageArgs)$/){
      return undef if defined $$info{stage};
      $$info{stage} = $arg;
    }else{
      return undef;
    }
  }

  $$info{game} = $singlesGameArg if not defined $$info{game};
  $$info{machine} = $defaultMachineArg if not defined $$info{machine};

  return $info;
}

sub getScoresByFile(){
  my @files = listScoreFiles();
  my $scoresByFile = { map {$_ => parseScoreFile $_} @files };
  return $scoresByFile;
}

sub listScoreFiles(){
  my @files = `cd $scoreDir && ls *.jpg`;
  chomp foreach @files;
  @files = grep {$_ =~ /^\d+_.*\.jpg$/} @files;
  @files = grep {$_ !~ /_reminder_/} @files;
  @files = grep {$_ !~ /_closeup_/} @files;
  return @files;
}

sub parseScoreFile($){
  my $file = shift;
  if($file !~ /^
    (?<date>\d{8})
    _(?<index>\d+)
    _(?<song>$okSongArgs)
    (?:_(?<game>$okGameArgs))?
    _(?<difficulty>$okDifficultyArgs)
    _(?<machine>$okMachineArgs)
    _(?<score>\d+)
    (?:_(?<extra>$okExtraArgs))?
    _(?<bar>$okBarArgs)
    _(?<stage>$okStageArgs)
    \.jpg$/x){
    die "malformed file name: $file\n";
  }
  my $info = {
    file       => $file,
    date       => $+{date},
    index      => $+{index},
    song       => $+{song},
    game       => $+{game},
    difficulty => $+{difficulty},
    machine    => $+{machine},
    score      => $+{score},
    extra      => $+{extra},
    bar        => $+{bar},
    stage      => $+{stage},
  };
  $$info{game} = $singlesGameArg if not defined $$info{game} or $$info{game} eq "";
  return $info;
}

sub sortScores($){
  my $scores = shift;
  return [sort {
    $$a{date} <=> $$b{date}
    ||
    $$a{game} cmp $$b{game}
    ||
    $$a{song} cmp $$b{song}
    ||
    $$a{difficulty} cmp $$b{difficulty}
    ||
    $$a{file} cmp $$b{file}
  } @$scores];
}

sub getBucketName($$@){
  my ($score, $abbrevBucket, @bucketFields) = @_;
  my @bucketFieldVals;
  for my $bucketField(@bucketFields){
    my $val = $$score{$bucketField};
    if($abbrevBucket){
      if($bucketField eq "song"){
        $val = $songAbbrevs{$val};
      }elsif($bucketField eq "difficulty"){
        if($val eq $defaultDifficulty{$$score{song}}){
          $val = undef;
        }else{
          $val = $difficultyAbbrevs{$val};
        }
      }elsif($bucketField eq "game"){
        if($val eq $singlesGameArg){
          $val = undef;
        }else{
          $val = $gameAbbrevs{$val};
        }
      }elsif($bucketField eq "machine"){
        if($val eq $defaultMachineArg){
          $val = undef;
        }
      }
    }
    push @bucketFieldVals, $val;
  }
  return join "-", grep {defined $_} @bucketFieldVals;
}

sub getScoreBuckets($$@){
  my ($scores, $abbrevBucket, @bucketFields) = @_;
  $scores = sortScores $scores;

  my $buckets = {};
  for my $score(@$scores){
    my $bucketName = getBucketName $score, $abbrevBucket, @bucketFields;
    $$buckets{$bucketName} = [] if not defined $$buckets{$bucketName};
    push @{$$buckets{$bucketName}}, $score;
  }
  return $buckets;
}

sub formatBucketCsv($$$){
  my ($okNotes, $bucketName, $bucketScores) = @_;

  my %isHardSong = map {$_ => 1} @hardSongs;

  $bucketScores = sortScores $bucketScores;

  my $maxScore = undef;
  my $maxScoreFile = undef;
  for my $s(@$bucketScores){
    if(not defined $maxScore or $$s{score} > $maxScore){
      $maxScore = $$s{score};
      $maxScoreFile = $$s{file};
    }
  }

  my $fmt = "";
  for my $s(@$bucketScores){
    my @notes;
    if($$okNotes{'extra'} and defined $$s{extra}){
      push @notes, $$s{extra};
    }
    if($$okNotes{'highscore'} and $$s{file} eq $maxScoreFile){
      my $abbrev = $songAbbrevs{$$s{song}};
      push @notes, "$$s{score} $abbrev";
    }
    if($$okNotes{'nobar'} and $$s{bar} eq "nobar" and $isHardSong{$$s{song}}){
      push @notes, $$s{bar};
    }
    if($$okNotes{'3rd'} and $$s{stage} eq "3rd" and $isHardSong{$$s{song}}){
      push @notes, $$s{stage};
    }

    my $note = join " ", @notes;
    $fmt .= "$$s{date},$$s{score},$note\n";
  }

  return $fmt;
}

sub getBucketBarCounts($){
  my $buckets = shift;
  my $bucketBarCounts = {};
  for my $bucketName(keys %$buckets){
    my $bucketScores = $$buckets{$bucketName};
    my $barCount = 0;
    my $nobarCount = 0;
    for my $score(@$bucketScores){
      $barCount++ if $$score{bar} eq "bar";
      $nobarCount++ if $$score{bar} eq "nobar";
    }
    $$bucketBarCounts{$bucketName}{bar} = $barCount;
    $$bucketBarCounts{$bucketName}{nobar} = $nobarCount;
  }
  return $bucketBarCounts;
}

sub filterScores($$){
  my ($scoresByFile, $filters) = @_;
  $scoresByFile = {%$scoresByFile};

  my $origScoresByFile = {%$scoresByFile};

  for my $file(sort keys %$scoresByFile){
    my $s = $$scoresByFile{$file};
    my $ok = 1;
    if(defined $$filters{songs}){
      my $f = $$filters{songs};
      my $song = $$s{song};
      if(defined $$f{$song} and not $$f{$song}){
        $ok = 0;
      }
    }
    if(defined $$filters{game}){
      my $f = $$filters{game};
      my $game = $$s{game};
      if(defined $$f{$game} and not $$f{$game}){
        $ok = 0;
      }
    }
    if(defined $$filters{machine}){
      my $f = $$filters{machine};
      my $machine = $$s{machine};
      if(defined $$f{$machine} and not $$f{$machine}){
        $ok = 0;
      }
    }
    if(defined $$filters{minscore}){
      my $f = $$filters{minscore};
      my $score = $$s{score};
      if($score < $f){
        $ok = 0;
      }
    }
    if(defined $$filters{maxscore}){
      my $f = $$filters{maxscore};
      my $score = $$s{score};
      if($score > $f){
        $ok = 0;
      }
    }
    if(defined $$filters{mindate}){
      my $f = $$filters{mindate};
      my $date = $$s{date};
      if($date < $f){
        $ok = 0;
      }
    }
    if(defined $$filters{maxdate}){
      my $f = $$filters{maxdate};
      my $date = $$s{date};
      if($date > $f){
        $ok = 0;
      }
    }
    delete $$scoresByFile{$file} if not $ok;
  }

  if($$filters{bar}){
    my $scores = [values %$origScoresByFile];
    my $buckets = getScoreBuckets($scores, 0, @DEFAULT_BUCKET_FIELDS);
    my $bucketBarCounts = getBucketBarCounts $buckets;
    for my $bucketName(sort keys %$buckets){
      my $bucketScores = $$buckets{$bucketName};
      my $barCount = $$bucketBarCounts{$bucketName}{bar};
      my $nobarCount = $$bucketBarCounts{$bucketName}{nobar};
      for my $score(@$bucketScores){
        my $bar = $$score{bar};
        my $sameCount = $bar eq "bar" ? $barCount : $nobarCount;
        my $diffCount = $bar eq "bar" ? $nobarCount : $barCount;
        if($$filters{bar} eq "bar" and $bar ne "bar"){
          delete $$scoresByFile{$$score{file}};
        }elsif($$filters{bar} eq "nobar" and $bar ne "nobar"){
          delete $$scoresByFile{$$score{file}};
        }elsif($$filters{bar} eq "same" and $sameCount < $diffCount){
          delete $$scoresByFile{$$score{file}};
        }elsif($$filters{bar} eq "diff" and $diffCount < $sameCount){
          delete $$scoresByFile{$$score{file}};
        }
      }
    }
  }

  if($$filters{monotonic}){
    my $scores = [values %$scoresByFile];
    my $buckets = getScoreBuckets($scores, 0, @DEFAULT_BUCKET_FIELDS);
    for my $bucketName(sort keys %$buckets){
      my $bucketScores = $$buckets{$bucketName};
      sortScores $bucketScores;
      my $curMaxScore = undef;
      for my $score(@$bucketScores){
        if(not defined $curMaxScore or $$score{score} > $curMaxScore){
          $curMaxScore = $$score{score};
        }else{
          delete $$scoresByFile{$$score{file}};
        }
      }
    }
  }

  die "no scores found\n" if keys %$scoresByFile == 0;

  return $scoresByFile;
}

sub formatScores($$$){
  my ($okNotes, $abbrevBucket, $filters) = @_;

  my $scoresByFile = getScoresByFile();
  $scoresByFile = filterScores $scoresByFile, $filters;

  my $scores = [values %$scoresByFile];
  my $buckets = getScoreBuckets($scores, $abbrevBucket, @DEFAULT_BUCKET_FIELDS);

  my $fmt = "";
  for my $bucketName(sort keys %$buckets){
    my $bucketScores = $$buckets{$bucketName};
    $fmt .= "\n\n" unless $fmt eq "";
    $fmt .= "\"$bucketName\"\n";
    $fmt .= formatBucketCsv $okNotes, $bucketName, $bucketScores;
  }
  return $fmt;
}

sub getBestScores($){
  my ($filters) = @_;

  my $scoresByFile = getScoresByFile();
  $scoresByFile = filterScores $scoresByFile, $filters;

  my $scores = [values %$scoresByFile];
  my $buckets = getScoreBuckets($scores, 0, @DEFAULT_BUCKET_FIELDS);

  my $bestScores = {};

  for my $bucketName(sort keys %$buckets){
    my $bucketScores = $$buckets{$bucketName};
    my $maxScore;
    for my $s(@$bucketScores){
      if(not defined $maxScore or $$s{score} > $$maxScore{score}){
        $maxScore = $s;
      }
    }
    $$bestScores{$bucketName} = $maxScore if defined $maxScore;
  }

  return $bestScores;
}

sub gnuplot($$){
  my ($plotOptions, $data) = @_;
  my $dataFile = "/tmp/ddrname-gnuplot-data";
  my $scriptFile = "/tmp/ddrname-gnuplot-script";

  my $outputFile = "/tmp/ddrname-gnuplot-output.png";
  $outputFile = $$plotOptions{file} if defined $$plotOptions{file};

  my $pngSize = $gnuplotDefaultPngSize;
  $pngSize = $$plotOptions{size} if defined $$plotOptions{size};

  my @segments = split /\n\n/, $data;
  my $segmentCount = @segments;
  my $lastBucket = $segmentCount - 1;

  my $script = "";
  $script .= "set xdata time\n";
  $script .= "set timefmt \"\%Y\%m\%d\"\n";
  $script .= "set datafile separator \",\"\n";
  $script .= "set key autotitle columnheader horizontal\n";
  $script .= "set grid noytics mxtics linewidth 4 , linewidth 2\n";

  $script .= "set term pngcairo size $pngSize\n";
  $script .= "set output \"$outputFile\"\n";

  my $linePlot = ""
    . " for [BUCKET=0:$lastBucket]"
    . " \"$dataFile\" index BUCKET"
    . " using 1:2"
    . " with linespoints"
    ;
  my $smoothPlot = ""
    . " for [BUCKET=0:$lastBucket]"
    . " \"$dataFile\" index BUCKET"
    . " using 1:2"
    . " smooth bezier"
    ;
  my $notesPlot = ""
    . " for [BUCKET=0:$lastBucket]"
    . " \"$dataFile\" index BUCKET"
    . " using 1:2:3"
    . " with labels offset 0,-1"
    . " notitle"
    ;

  my @plots = $$plotOptions{smooth} ? ($smoothPlot, $notesPlot) : ($linePlot, $notesPlot);

  $script .= "plot " . join(", ", @plots) . "\n";

  open FH, "> $dataFile" or die "Could not write $dataFile\n";
  print FH $data;
  close FH;
  open FH, "> $scriptFile" or die "Could not write $scriptFile\n";
  print FH $script;
  close FH;

  run "gnuplot", "-p", $scriptFile;
  die "error runnning gnuplot script:\n===\n$script===\n" if $? != 0;
}

sub combine(@){
  return ([]) if @_ == 0;
  my $e = shift;
  my @c;
  my @rest = combine @_;
  for my $list(@rest){
    push @c, [$e, @$list];
    push @c, [@$list];
  }
  return @c;
}

sub mtime($){
  my $path = shift;
  die "not a file or directory: $path\n" if not -e $path;
  my @stat = stat $path;
  return $stat[9];
}

sub getImageOrientation($){
  my $file = shift;
  die "not a file: $file\n" if not -f $file;
  my ($width, $height, $orient);

  open FH, "-|", $EXIFTOOL_EXEC, "-ImageWidth", "-ImageHeight", "-Orientation", $file;
  while(my $line = <FH>){
    $width = $1 if $line =~ /^Image Width\s*:\s*(\d+)$/;
    $height = $1 if $line =~ /^Image Height\s*:\s*(\d+)$/;
    $orient = $1 if $line =~ /^Orientation\s*:\s*(.*)$/;
  }
  close FH;

  if(not defined $height or not defined $width){
    my $pix = `$PIX_EXEC $file 2>/dev/null`;
    if($pix =~ /^(\d+)x(\d+)$/){
      ($height, $width) = ($1, $2);
    }
  }

  if(defined $orient and $orient =~ /Rotate.*90|Rotate.*270/){
    ($width, $height) = ($height, $width);
  }

  if(not defined $height or not defined $width){
    return undef;
  }elsif($height > $width){
    return "portrait";
  }else{
    return "landscape";
  }
}

sub bashComplete($$){
  my ($cmdLine, $pos) = @_;
  my $cmd = substr $cmdLine, 0, $pos;
  my $isNewWord = $cmd =~ /\s$/;
  $cmd =~ s/^\s+//;
  $cmd =~ s/\s+$//;

  my @words = split /\s+/, $cmd;
  shift @words;
  pop @words if not $isNewWord;

  if(@words == 0){
    my @jpgFiles = `ls *.jpg 2>/dev/null`;
    chomp foreach @jpgFiles;
    return ("--fehterm", "--orientation", "--datestats", "--coursestats",
      "--print", "--gnuplot", "--files", "--bestfiles", @jpgFiles);
  }

  if($words[0] =~ /^(--print|--gnuplot|--files|--bestfiles|--datestats|--coursestats|--orientation)$/){
    my $cmd = shift @words;
    my @complete;
    my $lastWord = $words[-1] if @words > 0;
    $lastWord = "" if not defined $lastWord;

    if($cmd =~ /^(--print|--gnuplot|--files|--bestfiles|--datestats|--coursestats|--orientation)$/){
      if($lastWord =~ /^(--song)$/){
        return @songArgs;
      }elsif($lastWord =~ /^($argOptFiltersRegex)$/){
        return ();
      }
    }

    if($cmd =~ /^(--print|--gnuplot)$/){
      if($lastWord =~ /^(--notes)$/){
        my @combinations = combine sort keys %$defaultNotes;
        my @csv = sort map {join ",", @$_} @combinations;
        return sort @csv;
      }elsif($lastWord =~ /^($argOptFormatOptSongsRegex)$/){
        return ();
      }
    }

    if($cmd =~ /^(--gnuplot)$/){
      while(@words > 0 and $words[0] =~ /^($okPlotOptionsRegex)$/){
        my $opt = shift @words;
        if(@words == 0 and $opt =~ /^($argOptPlotOptionsRegex)$/){
          return ();
        }
        shift @words if $opt =~ /^($argOptPlotOptionsRegex)$/;
      }
      if(@words == 0){
        @complete = (@okPlotOptions, @complete);
      }
    }
    if($cmd =~ /^(--print|--gnuplot)/){
      @complete = (@okFormatOptSongs, @complete) if @words == 0;
    }
    if($cmd =~ /^(--datestats)/){
      my @args = @words;
      while(@args > 0 and $args[0] =~ /^($okFormatOptDatesRegex)$/){
        my $opt = shift @args;
        if(@args == 0 and $opt =~ /^($argOptFormatOptDatesRegex)$/){
          return ();
        }
        shift @args if $opt =~ /^($argOptFormatOptDatesRegex)$/;
      }
      @complete = (@okFormatOptDates, @complete) if @args == 0;
    }
    if($cmd =~ /^(--coursestats)/){
      my @args = @words;
      while(@args > 0 and $args[0] =~ /^($okFormatOptCoursesRegex)$/){
        my $opt = shift @args;
        if(@args == 0 and $opt =~ /^($argOptFormatOptCoursesRegex)$/){
          if(defined $opt and $opt =~ /^(--minlen)$/){
            return ("1", "2", "3");
          }else{
            return ();
          }
        }
        shift @args if $opt =~ /^($argOptFormatOptCoursesRegex)$/;
      }
      @complete = ("--minlen", @complete) if @args == 0;
    }
    @complete = (@okFilters, @complete);
    return @complete;
  }

  shift @words;

  my $info = parseArgs @words;
  if(not defined $info){
    return ();
  }

  my @complete;
  @complete = (@songArgs, @complete) if not defined $$info{song};
  #@complete = (@gameArgs, @complete) if not defined $$info{game};
  @complete = (@difficultyArgs, @complete) if not defined $$info{difficulty};
  #@complete = (@machineArgs, @complete) if not defined $$info{machine};
  #@complete = (@extraArgs, @complete) if not defined $$info{extra};
  @complete = (@barArgs, @complete) if not defined $$info{bar};
  @complete = (@stageArgs, @complete) if not defined $$info{stage};

  @complete = ("reminder_", "closeup_", @complete) if @words == 0;

  return @complete;
}

sub warnMsg($){
  my $msg = shift;
  print STDERR "\n\nWARN: $msg\n";
}

sub run(@){
  print "@_\n";
  system @_;
}

&main(@ARGV);
