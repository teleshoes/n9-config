#!/usr/bin/python
#n9-button-monitor v0.1
#Copyright 2012 Elliot Wolk
#based on:
#####
# Ye Olde Camerra Hack - Another fine Harmattan Hack Powered by Python(tm)!
# 2012-01-12; Thomas Perl <thp.io/about>
#####
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#

from QmSystem import *
from PySide.QtGui import *
from PySide.QtDeclarative import *

import sys
import os
import subprocess
import re

###############
###############
###############
def getActions():
  return filter(None, [ None
  , Action([volup], cond=appOnTop("camera-ui"), action=cmd("camera-click"))
  , Action([voldn, volup, volup], cond=screenLocked, action=cmd("torch"))
  , Action([volup], cond=screenLocked, action=cmd("udo klomp-cmd pause"))
  , Action([voldn], cond=screenLocked, action=cmd("udo klomp-cmd next"))
  ])

def readProc(cmdarr):
  out, err = subprocess.Popen(cmdarr, stdout=subprocess.PIPE).communicate()
  return out

def screenLocked():
  return "locked\n" == readProc(['lock', '-g'])
def screenUnlocked():
  return not screenLocked()

def appOnTop(app):
  return lambda: isAppOnTop(app)
def isAppOnTop(app):
  winId = readProc(["xprop", "-root", "_NET_ACTIVE_WINDOW"]) [40:]
  winCmd = readProc(["xprop", "-id", winId, "WM_COMMAND"]) [24:-4]
  return app in winCmd

def cmd(cmd):
  return lambda: runcmd(cmd)
def runcmd(cmd):
  print 'running cmd: "' + cmd + '"'
  subprocess.Popen(['bash', '-c', cmd])
###############
###############
###############

evtPressed = 'pressed'
evtRepeated = 'repeated'
evtReleased = 'released'

stateOn = 2
stateOff = 0

power = 20
volup = 2
voldn = 3

class Action():
  def __init__(self, pattern, action=None, cond=None):
    self.pattern = pattern
    self.action = action
    self.cond = cond

keysPressed = set()
actions = getActions()
pattern = []

def keyEvent(key, state):
  event = None
  if state == stateOn:
    if key not in keysPressed:
      event = evtPressed
    else:
      event = evtRepeated
    keysPressed.add(key)
  elif state == stateOff:
    event = evtReleased
    keysPressed.discard(key)

  if event == evtRepeated:
    return

  if event == evtPressed:
    pattern.append(key)

  if event == evtReleased and len(pattern) > 0 and pattern[0] == key:
    for action in actions:
      if action.pattern == pattern:
        if action.cond == None or action.cond():
          action.action()
    del pattern[:]

def main():
  app = QApplication(sys.argv)
  keys = QmKeys()
  keys.keyEvent.connect(keyEvent)
  app.exec_()

if __name__ == "__main__":
  sys.exit(main())

